diff --git a/cmd/changie/main.go b/cmd/changie/main.go
index 79ed11d..54104b3 100644
--- a/cmd/changie/main.go
+++ b/cmd/changie/main.go
@@ -109,20 +109,52 @@ var (
 	changelogFixedContent      = changelogFixedCommand.Arg("content", "Content to add to the changelog").Required().String()
 	changelogSecurityCommand   = changelogCommand.Command("security", "Add a security section to changelog.")
 	changelogSecurityContent   = changelogSecurityCommand.Arg("content", "Content to add to the changelog").Required().String()
-	version                    = "dev" // default version if not set during build
 )
 
 var isGitInstalled = git.IsInstalled
 var isTestMode bool
 
-func handleVersionBump(bumpType string, changelogManager ChangelogManager, gitManager GitManager, semverManager SemverManager) error {
-	hasUncommittedChanges, err := gitManager.HasUncommittedChanges()
+// getVersion returns the current version of changie based on git tags and commits
+func getVersion() (string, error) {
+	// version represents the current version of changie.
+	// It's dynamically set based on git tags and commits:
+	// - If on a tagged commit: "<tag>" (e.g., "1.2.3")
+	// - If ahead of the latest tag: "<tag>-dev.<commits-ahead>+<commit-sha>" (e.g., "1.2.3-dev.5+a1b2c3d")
+	// - If no tags found: "dev"
+	// Get the latest tag
+	latestTag, err := exec.Command("git", "describe", "--tags", "--abbrev=0").Output()
 	if err != nil {
-		return fmt.Errorf("Error checking for uncommitted changes: %v", err)
+		if exitError, ok := err.(*exec.ExitError); ok && exitError.ExitCode() == 128 {
+			// Exit code 128 typically means no tags found
+			return "dev", nil
+		}
+		return "", fmt.Errorf("error getting latest tag: %w", err)
 	}
-	if hasUncommittedChanges {
-		return fmt.Errorf("Error: Uncommitted changes found. Please commit or stash your changes before bumping the version.")
+	tag := strings.TrimSpace(string(latestTag))
+
+	// Get the current commit hash
+	commitHash, err := exec.Command("git", "rev-parse", "--short", "HEAD").Output()
+	if err != nil {
+		return "", fmt.Errorf("error getting commit hash: %w", err)
+	}
+
+	// Check if the current commit is tagged
+	if _, err := exec.Command("git", "describe", "--exact-match", "--tags", "HEAD").Output(); err == nil {
+		// Current commit is tagged, return the tag
+		return tag, nil
 	}
+
+	// Count commits since the latest tag
+	revList, err := exec.Command("git", "rev-list", tag+"..HEAD", "--count").Output()
+	if err != nil {
+		return "", fmt.Errorf("error counting commits since last tag: %w", err)
+	}
+
+	commitCount := strings.TrimSpace(string(revList))
+	return fmt.Sprintf("%s-dev.%s+%s", tag, commitCount, strings.TrimSpace(string(commitHash))), nil
+}
+
+func checkVersionMismatch(gitManager GitManager, changelogManager ChangelogManager, isTestMode bool) error {
 	gitVersion, err := gitManager.GetProjectVersion()
 	if err != nil {
 		return fmt.Errorf("Error getting project version: %v", err)
@@ -133,7 +165,7 @@ func handleVersionBump(bumpType string, changelogManager ChangelogManager, gitMa
 		return fmt.Errorf("Error reading changelog: %v", err)
 	}
 
-	changelogVersion, err := changelog.GetLatestChangelogVersion(changelogContent)
+	changelogVersion, err := GetLatestChangelogVersion(changelogContent)
 	if err != nil {
 		return fmt.Errorf("Error getting changelog version: %v", err)
 	}
@@ -145,6 +177,25 @@ func handleVersionBump(bumpType string, changelogManager ChangelogManager, gitMa
 		return fmt.Errorf("Version mismatch: Git tag version %s does not match changelog version %s", gitVersion, changelogVersion)
 	}
 
+	return nil
+}
+
+func handleVersionBump(bumpType string, changelogManager ChangelogManager, gitManager GitManager, semverManager SemverManager) error {
+	hasUncommittedChanges, err := gitManager.HasUncommittedChanges()
+	if err != nil {
+		return fmt.Errorf("Error checking for uncommitted changes: %v", err)
+	}
+	if hasUncommittedChanges {
+		return fmt.Errorf("Error: Uncommitted changes found. Please commit or stash your changes before bumping the version.")
+	}
+
+	if err := checkVersionMismatch(gitManager, changelogManager, isTestMode); err != nil {
+		return err
+	}
+
+	gitVersion, _ := gitManager.GetProjectVersion() // We can ignore the error here as it's already checked in checkVersionMismatch
+	fmt.Printf("Current version from git tags: %s\n", gitVersion)
+
 	fmt.Printf("Current version from git tags: %s\n", gitVersion)
 
 	var bumpFunc func(string) (string, error)
@@ -212,29 +263,7 @@ func handleChangelogUpdate(section, content string, changelogManager ChangelogMa
 	return nil
 }
 
-func checkVersionMismatch(gitManager GitManager, changelogManager ChangelogManager) error {
-	gitVersion, err := gitManager.GetProjectVersion()
-	if err != nil {
-		return fmt.Errorf("Error getting project version: %v", err) // Updated this line
-	}
-
-	changelogContent, err := changelogManager.GetChangelogContent()
-	if err != nil {
-		return fmt.Errorf("Error reading changelog: %v", err)
-	}
-
-	changelogVersion, err := changelog.GetLatestChangelogVersion(changelogContent)
-	if err != nil {
-		return fmt.Errorf("Error getting changelog version: %v", err)
-	}
-
-	if gitVersion != changelogVersion {
-		return fmt.Errorf("Version mismatch: Git tag version %s does not match changelog version %s", gitVersion, changelogVersion)
-	}
-
-	return nil
-}
-func getLatestChangelogVersion(content string) (string, error) {
+func GetLatestChangelogVersion(content string) (string, error) {
 	re := regexp.MustCompile(`## \[(\d+\.\d+\.\d+)\]`)
 	matches := re.FindStringSubmatch(content)
 	if len(matches) < 2 {
@@ -245,7 +274,7 @@ func getLatestChangelogVersion(content string) (string, error) {
 
 func run(changelogManager ChangelogManager, gitManager GitManager, semverManager SemverManager) error {
 	// Get the git tag
-	version, err := getLatestGitTag()
+	version, err := getVersion()
 	if err != nil {
 		fmt.Printf("Error getting git tag: %v\n", err)
 		version = "dev" // fallback version
@@ -297,20 +326,13 @@ func run(changelogManager ChangelogManager, gitManager GitManager, semverManager
 	return nil
 }
 
-// Function to get the latest git tag
-func getLatestGitTag() (string, error) {
-	cmd := exec.Command("git", "describe", "--tags", "--abbrev=0")
-	out, err := cmd.Output()
-	if err != nil {
-		return "", err
-	}
-	return strings.TrimSpace(string(out)), nil
-}
-
 func main() {
 	// Enable verbose logging
 	log.SetFlags(log.LstdFlags | log.Lshortfile)
 
+	// The version is dynamically set based on git tags and commits.
+	// See the 'version' variable declaration for details on the versioning scheme.
+
 	changelogManager := DefaultChangelogManager{}
 	gitManager := DefaultGitManager{}
 	semverManager := DefaultSemverManager{}
diff --git a/cmd/changie/main_test.go b/cmd/changie/main_test.go
index bffe7dd..653f048 100644
--- a/cmd/changie/main_test.go
+++ b/cmd/changie/main_test.go
@@ -5,6 +5,7 @@ import (
 	"fmt"
 	"io"
 	"os"
+	"os/exec"
 	"strconv"
 	"strings"
 	"testing"
@@ -126,7 +127,7 @@ func (m *MockSemverManager) BumpPatch(version string) (string, error) {
 	return fmt.Sprintf("%d.%d.%d", major, minor, patch+1), nil
 }
 
-func captureOutput(f func() error) (string, error) {
+func captureOutput(t *testing.T, f func() error) (string, error) {
 	oldStdout := os.Stdout
 	oldStderr := os.Stderr
 	r, w, _ := os.Pipe()
@@ -140,7 +141,9 @@ func captureOutput(f func() error) (string, error) {
 	os.Stderr = oldStderr
 
 	var buf bytes.Buffer
-	io.Copy(&buf, r)
+	if _, err := io.Copy(&buf, r); err != nil {
+		t.Fatalf("Failed to copy output: %v", err)
+	}
 	return buf.String(), err
 }
 
@@ -300,7 +303,7 @@ func TestMainPackage(t *testing.T) {
 		t.Run(tt.name, func(t *testing.T) {
 			os.Args = tt.args
 
-			output, err := captureOutput(func() error {
+			output, err := captureOutput(t, func() error {
 				return run(tt.changelogManager, tt.gitManager, tt.semverManager)
 			})
 
@@ -327,7 +330,7 @@ func TestGitNotInstalled(t *testing.T) {
 
 	os.Args = []string{"changie", "major"}
 
-	output, err := captureOutput(func() error {
+	output, err := captureOutput(t, func() error {
 		return run(&MockChangelogManager{}, &MockGitManager{}, &MockSemverManager{})
 	})
 
@@ -340,13 +343,88 @@ func TestGitNotInstalled(t *testing.T) {
 	}
 }
 
+func TestGetVersion(t *testing.T) {
+	// Save the current working directory
+	pwd, err := os.Getwd()
+	if err != nil {
+		t.Fatalf("Failed to get current directory: %v", err)
+	}
+	defer func() {
+		if err := os.Chdir(pwd); err != nil {
+			t.Errorf("Failed to change directory back: %v", err)
+		}
+	}()
+	// Create a temporary directory for the test
+	tmpDir, err := os.MkdirTemp("", "changie-test")
+	if err != nil {
+		t.Fatalf("Failed to create temp dir: %v", err)
+	}
+	defer os.RemoveAll(tmpDir)
+
+	// Change to the temporary directory
+	defer func() {
+		if err := os.Chdir(pwd); err != nil {
+			t.Errorf("Failed to change directory back: %v", err)
+		}
+	}()
+
+	// Initialize a git repository
+	if err := exec.Command("git", "init").Run(); err != nil {
+		t.Fatalf("Failed to initialize git repo: %v", err)
+	}
+	if err := exec.Command("git", "config", "user.email", "test@example.com").Run(); err != nil {
+		t.Fatalf("Failed to configure git user.email: %v", err)
+	}
+	if err := exec.Command("git", "config", "user.name", "Test User").Run(); err != nil {
+		t.Fatalf("Failed to configure git user.name: %v", err)
+	}
+
+	// Test case 1: No tags
+	version, err := getVersion()
+	if err != nil {
+		t.Fatalf("Failed to get version: %v", err)
+	}
+	if version != "dev" {
+		t.Errorf("Expected 'dev', got '%s'", version)
+	}
+
+	// Create a commit
+	if err := exec.Command("git", "commit", "--allow-empty", "-m", "Initial commit").Run(); err != nil {
+		t.Fatalf("Failed to create initial commit: %v", err)
+	}
+
+	// Test case 2: With a tag
+	if err := exec.Command("git", "tag", "v1.0.0").Run(); err != nil {
+		t.Fatalf("Failed to create tag: %v", err)
+	}
+	version, err = getVersion()
+	if err != nil {
+		t.Fatalf("Failed to get version: %v", err)
+	}
+	if version != "v1.0.0" {
+		t.Errorf("Expected 'v1.0.0', got '%s'", version)
+	}
+
+	// Test case 3: Commit after tag
+	if err := exec.Command("git", "commit", "--allow-empty", "-m", "Another commit").Run(); err != nil {
+		t.Fatalf("Failed to create another commit: %v", err)
+	}
+	version, err = getVersion()
+	if err != nil {
+		t.Fatalf("Failed to get version: %v", err)
+	}
+	if len(version) <= 7 || version[:7] != "v1.0.0-" {
+		t.Errorf("Expected version starting with 'v1.0.0-', got '%s'", version)
+	}
+}
+
 func TestInvalidCommand(t *testing.T) {
 	originalArgs := os.Args
 	defer func() { os.Args = originalArgs }()
 
 	os.Args = []string{"changie", "invalid"}
 
-	output, err := captureOutput(func() error {
+	output, err := captureOutput(t, func() error {
 		return run(&MockChangelogManager{}, &MockGitManager{}, &MockSemverManager{})
 	})
 
@@ -393,7 +471,7 @@ func TestMinorVersionBump(t *testing.T) {
 	// Reset the tagVersionCalled counter before running the test
 	mockGitManager.ResetTagVersionCalled()
 
-	output, err := captureOutput(func() error {
+	output, err := captureOutput(t, func() error {
 		return run(mockChangelogManager, mockGitManager, mockSemverManager)
 	})
 
@@ -480,7 +558,7 @@ func TestRejectBumpWithUncommittedChanges(t *testing.T) {
 	}
 	mockSemverManager := &MockSemverManager{}
 
-	output, err := captureOutput(func() error {
+	output, err := captureOutput(t, func() error {
 		return run(mockChangelogManager, mockGitManager, mockSemverManager)
 	})
 
@@ -534,7 +612,7 @@ func TestAllowBumpWithNoUncommittedChanges(t *testing.T) {
 	}
 	mockSemverManager := &MockSemverManager{}
 
-	output, err := captureOutput(func() error {
+	output, err := captureOutput(t, func() error {
 		return run(mockChangelogManager, mockGitManager, mockSemverManager)
 	})
 
@@ -584,7 +662,7 @@ func TestAutoPushAfterBump(t *testing.T) {
 	}
 	mockSemverManager := &MockSemverManager{}
 
-	output, err := captureOutput(func() error {
+	output, err := captureOutput(t, func() error {
 		return run(mockChangelogManager, mockGitManager, mockSemverManager)
 	})
 
@@ -641,7 +719,7 @@ func TestVersionBumpWithExistingTag(t *testing.T) {
 	}
 	mockSemverManager := &MockSemverManager{}
 
-	output, err := captureOutput(func() error {
+	output, err := captureOutput(t, func() error {
 		return run(mockChangelogManager, mockGitManager, mockSemverManager)
 	})
 
diff --git a/internal/changelog/changelog.go b/internal/changelog/changelog.go
index 647755f..7aeb449 100644
--- a/internal/changelog/changelog.go
+++ b/internal/changelog/changelog.go
@@ -3,6 +3,7 @@ package changelog
 import (
 	"fmt"
 	"os"
+	"os/exec"
 	"regexp"
 	"sort"
 	"strings"
@@ -44,6 +45,8 @@ func GetLatestChangelogVersion(content string) (string, error) {
 	return matches[1], nil
 }
 
+var execCommand = exec.Command
+
 // UpdateChangelog updates the CHANGELOG.md file with the new version
 func UpdateChangelog(file string, version string, provider string) error {
 	content, err := os.ReadFile(file)
diff --git a/internal/changelog/changelog_test.go b/internal/changelog/changelog_test.go
index 06ade5f..3d0fee0 100644
--- a/internal/changelog/changelog_test.go
+++ b/internal/changelog/changelog_test.go
@@ -1,6 +1,7 @@
 package changelog
 
 import (
+	"fmt"
 	"os"
 	"os/exec"
 	"strings"
@@ -8,9 +9,9 @@ import (
 	"time"
 )
 
-var execCommand = exec.Command
-
 // Use this function to mock exec.Command in tests
+//
+//nolint:unused // This function is intended for future use in mocking exec.Command
 func mockExecCommand(command string, args ...string) *exec.Cmd {
 	cs := []string{"-test.run=TestHelperProcess", "--", command}
 	cs = append(cs, args...)
@@ -24,9 +25,36 @@ func TestHelperProcess(t *testing.T) {
 	if os.Getenv("GO_WANT_HELPER_PROCESS") != "1" {
 		return
 	}
-	// mock behavior here
-	os.Exit(0)
+	defer os.Exit(0)
+
+	args := os.Args
+	for len(args) > 0 {
+		if args[0] == "--" {
+			args = args[1:]
+			break
+		}
+		args = args[1:]
+	}
+	if len(args) == 0 {
+		fmt.Fprintf(os.Stderr, "No command\n")
+		os.Exit(2)
+	}
+
+	cmd, args := args[0], args[1:]
+	switch cmd {
+	case "git":
+		if len(args) > 0 && args[0] == "describe" {
+			fmt.Fprintf(os.Stdout, "1.0.0\n")
+		} else {
+			fmt.Fprintf(os.Stderr, "unknown git command\n")
+			os.Exit(1)
+		}
+	default:
+		fmt.Fprintf(os.Stderr, "Unknown command %q\n", cmd)
+		os.Exit(2)
+	}
 }
+
 func TestInitProject(t *testing.T) {
 	// Create a temporary directory for testing
 	tempDir, err := os.MkdirTemp("", "changie-test")
@@ -40,8 +68,14 @@ func TestInitProject(t *testing.T) {
 	if err != nil {
 		t.Fatalf("Failed to get current working directory: %v", err)
 	}
-	defer os.Chdir(oldWd)
-	os.Chdir(tempDir)
+	defer func() {
+		if err := os.Chdir(oldWd); err != nil {
+			t.Errorf("Failed to change directory back: %v", err)
+		}
+	}()
+	if err := os.Chdir(tempDir); err != nil {
+		t.Fatalf("Failed to change to temp directory: %v", err)
+	}
 
 	changelogFile := "CHANGELOG.md"
 
@@ -64,6 +98,7 @@ func TestInitProject(t *testing.T) {
 		t.Errorf("Unexpected error message: %v", err)
 	}
 }
+
 func TestAddChangelogSection(t *testing.T) {
 	tests := []struct {
 		name            string
@@ -379,6 +414,10 @@ func TestNoExtraLineInChangelog(t *testing.T) {
 }
 
 func TestUpdateChangelogFormatting(t *testing.T) {
+	// Save the original execCommand and defer its restoration
+	oldExecCommand := execCommand
+	defer func() { execCommand = oldExecCommand }()
+
 	initialContent := `# Changelog
 
 ## [Unreleased]
@@ -423,11 +462,10 @@ func TestUpdateChangelogFormatting(t *testing.T) {
 		t.Fatal(err)
 	}
 
-	// Mock git command to return "1.0.0"
-	execCommand = func(name string, arg ...string) *exec.Cmd {
-		return exec.Command("echo", "1.0.0")
+	// Mock execCommand to use mockExecCommand
+	execCommand = func(command string, args ...string) *exec.Cmd {
+		return mockExecCommand(command, args...)
 	}
-	defer func() { execCommand = exec.Command }()
 
 	// Update changelog
 	err = UpdateChangelog(tmpfile.Name(), "1.1.0", "github")
diff --git a/internal/git/git.go b/internal/git/git.go
index e893f8f..fd05fe8 100644
--- a/internal/git/git.go
+++ b/internal/git/git.go
@@ -22,6 +22,15 @@ func IsInstalled() bool {
 	return err == nil
 }
 
+func GetLastTag() (string, error) {
+	cmd := ExecCommand("git", "describe", "--tags", "--abbrev=0")
+	output, err := cmd.CombinedOutput()
+	if err != nil {
+		return "", err
+	}
+	return strings.TrimSpace(string(output)), nil
+}
+
 // GetProjectVersion retrieves the current project version from Git tags
 func GetProjectVersion() (string, error) {
 	cmd := ExecCommand("git", "describe", "--tags", "--abbrev=0")
diff --git a/internal/git/git_test.go b/internal/git/git_test.go
index b4cc03c..8e3440d 100644
--- a/internal/git/git_test.go
+++ b/internal/git/git_test.go
@@ -6,8 +6,6 @@ import (
 	"testing"
 )
 
-var executedCmd []string
-
 type mockCmd struct {
 	output string
 	err    error
@@ -23,6 +21,60 @@ func TestIsInstalled(t *testing.T) {
 	}
 }
 
+func TestGetLastTag(t *testing.T) {
+	// Save the current ExecCommand and defer its restoration
+	oldExecCommand := ExecCommand
+	defer func() { ExecCommand = oldExecCommand }()
+
+	tests := []struct {
+		name           string
+		mockOutput     string
+		mockError      error
+		expectedResult string
+		expectedError  bool
+	}{
+		{
+			name:           "Successful tag retrieval",
+			mockOutput:     "1.2.3\n",
+			mockError:      nil,
+			expectedResult: "1.2.3",
+			expectedError:  false,
+		},
+		{
+			name:           "No tags found",
+			mockOutput:     "",
+			mockError:      fmt.Errorf("exit status 128"),
+			expectedResult: "",
+			expectedError:  true,
+		},
+	}
+
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			ExecCommand = func(command string, args ...string) Commander {
+				return &mockCmd{
+					output: tt.mockOutput,
+					err:    tt.mockError,
+				}
+			}
+
+			result, err := GetLastTag()
+
+			if tt.expectedError {
+				if err == nil {
+					t.Errorf("Expected an error, but got none")
+				}
+			} else {
+				if err != nil {
+					t.Errorf("Unexpected error: %v", err)
+				}
+				if result != tt.expectedResult {
+					t.Errorf("Expected %s, but got %s", tt.expectedResult, result)
+				}
+			}
+		})
+	}
+}
 func TestGetProjectVersion(t *testing.T) {
 	// Save the current ExecCommand and defer its restoration
 	oldExecCommand := ExecCommand
